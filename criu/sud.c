#include <linux/filter.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <ptrace.h>

#include "common/config.h"
#include "imgset.h"
#include "kcmp.h"
#include "pstree.h"
#include <compel/ptrace.h>
#include "proc_parse.h"
#include "restorer.h"
#include "sud.h"
#include "servicefd.h"
#include "util.h"
#include "rst-malloc.h"

#include "protobuf.h"
#include "images/sud.pb-c.h"

#undef LOG_PREFIX
#define LOG_PREFIX "sys-dispatch: "

static struct rb_root sud_tid_rb_root = RB_ROOT;
static struct sys_dispatch_entry *sud_tid_entry_root;

/* Autogenerated protobuf message structure */
static SysDispatchEntry *sud_img_entry;

struct sys_dispatch_entry *sud_lookup(pid_t tid_real, bool create, bool mandatory)
{
    struct sys_dispatch_entry *entry = NULL;

    struct rb_node *node = sud_tid_rb_root.rb_node;
    struct rb_node **new = &sud_tid_rb_root.rb_node;
    struct rb_node *parent = NULL;

    while (node) {
        struct sys_dispatch_entry *this = rb_entry(node, struct sys_dispatch_entry, node);

        parent = *new;
        if (tid_real < this->tid_real)
            node = node->rb_left, new = &((*new)->rb_left);
        else if (tid_real > this->tid_real)
            node = node->rb_right, new = &((*new)->rb_right);
        else
            return this;
    }

    if (create) {
        entry = xzalloc(sizeof(*entry));
        if (!entry)
            return NULL;
        rb_init_node(&entry->node);
        entry->tid_real = tid_real;

        entry->next = sud_tid_entry_root, sud_tid_entry_root = entry;
        rb_link_and_balance(&sud_tid_rb_root, &entry->node, parent, new);
    } else {
        if (mandatory)
            pr_err("Can't find entry on tid_real %d\n", tid_real);
    }

    return entry;
}

/* This must run after ptrace freeze but *before* parasite code. */
int sud_collect_entry(pid_t tid_real)
{
    struct sys_dispatch_entry *entry;
    sud_config_t config;

    entry = sud_lookup(tid_real, true, false);
    if (!entry) {
        pr_err("Can't create entry on tid_real %d\n", tid_real);
        return -1;
    }

    if (ptrace_get_sud(tid_real, &config)) {
        pr_err("Failed to get SUD settings for %d\n", tid_real);
        return -1;
    }

    entry->mode = config.mode;
    entry->selector = config.selector;
    entry->offset = config.offset;
    entry->len = config.len;

    return 0;
}

int dump_sud_per_core(pid_t tid_real, ThreadCoreEntry *tc)
{
	struct sys_dispatch_entry *entry = sud_find_entry(tid_real);
	if (!entry) {
		pr_err("Can't dump thread core on tid_real %d\n", tid_real);
		return -1;
	}

	if (entry->mode == SYS_DISPATCH_ON) {
		tc->has_sud_mode = true;
		tc->sud_mode = entry->mode;
		tc->has_sud_setting = true;
		tc->sud_setting = entry->img_setting_pos;
	}

	return 0;
}

/* Traverse the nodes from collect_entry, and write data to protobuf */
int dump_sud(void)
{
	SysDispatchEntry se = SYS_DISPATCH_ENTRY__INIT;
	SysDispatchSetting *settings = NULL;
	struct sys_dispatch_entry *entry = NULL;
	size_t img_setting_pos = 0, nr_settings = 0, i;
	struct rb_node *node;
	int ret = -1;

	/* Get the number of entries in the collect ring buffer */
	for (node = rb_first(&sud_tid_rb_root); node; node = rb_next(node)) {
		entry = rb_entry(node, struct sys_dispatch_entry, node);
		nr_settings += 1;
	}

	/* Allocate space for dumping the thread settings */
	se.n_settings = nr_settings;
	if (nr_settings) {
		se.settings = xmalloc(sizeof(*se.settings) * nr_settings);
		if (!se.settings)
			goto cleanup_exit;
		settings = xmalloc(sizeof(*settings) * nr_settings);
		if (!settings)
			goto cleanup_exit;
		/*
		 * Fill the list of pointers with setting addresses,
		 * initializing the protobuf structs on the way
		 */
		for (i = 0; i < nr_settings; ++i) {
			sys_dispatch_setting__init(&settings[i]);
			se.settings[i] = &settings[i];
		}
	}

	/* Traverse again, this time writing the settings to img format */
	for (node = rb_first(&sud_tid_rb_root); node; node = rb_next(node)) {
		entry = rb_entry(node, struct sys_dispatch_entry, node);

		if (entry->mode == SYS_DISPATCH_ON) {
			se.settings[img_setting_pos]->selector = entry->selector;
			se.settings[img_setting_pos]->offset = entry->offset;
			se.settings[img_setting_pos]->len = entry->len;
			entry->img_setting_pos = img_setting_pos++;
		}
	}

	ret = pb_write_one(img_from_set(glob_imgset, CR_FD_SYS_DISPATCH), &se, PB_SYS_DISPATCH);

cleanup_exit:
	/* Once saved to disk, we don't need to keep the data structures allocated */
	xfree(se.settings);
	xfree(settings);

	return ret;
}
